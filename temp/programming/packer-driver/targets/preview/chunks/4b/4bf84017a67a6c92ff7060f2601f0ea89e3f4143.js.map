{"version":3,"sources":["file:///D:/cocos_work/SimulateCity/assets/src/MapMgr.ts"],"names":["MapMgr","BoxCollider","Line","MeshRenderer","Node","Quat","Vec3","geometry","v3","GlobalConst","ray","v3_1","worldMatrix","qt_1","mapHitPoint","constructor","_node","_meshRender","ins","_ins","node","mapPanel","getComponent","graphicsMapLine","box","lineBox","addChild","line","addComponent","set","worldBounds","halfExtents","hGridCount","Math","floor","x","mapGridWidth","vGridCount","z","mapGridHeight","y","positions","push","width","constant","calculateHitPoint","vec2","out","camera","screenPointToRay","dis","intersect","rayModel","model","computeHit","getHitPointToGrid","inverseTransformPoint","scale","scaleX","scaleY","getHitPointToGridPosition","outGrid","_setMapPos","getWorldMatrix","transformMat4"],"mappings":"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","sourcesContent":["import { BoxCollider, Line, MeshRenderer, Node, Quat, Vec2, Vec3, geometry, v3 } from \"cc\";\r\nimport { GlobalConst, ray, v3_1, worldMatrix } from \"./GlobalConst\";\r\n\r\n\r\nconst qt_1 = new Quat();\r\nconst mapHitPoint: Vec3 = new Vec3();\r\n\r\nexport class MapMgr {\r\n\r\n    // 地图块的计算，当前地图有多少格子，那些格子可用\r\n    // 当前地图存在的建筑物\r\n    // 建筑物对应的状态\r\n    // 各个建筑物的状态更新\r\n    _node: Node;\r\n    _meshRender: MeshRenderer;\r\n    constructor() {\r\n\r\n    }\r\n\r\n\r\n    private static _ins: MapMgr;\r\n    public static get ins() {\r\n        return this._ins ||= new MapMgr();\r\n    }\r\n\r\n\r\n    public get node() {\r\n        this._node ||= GlobalConst.mapPanel\r\n        if (!this._meshRender) {\r\n            this._meshRender = this._node.getComponent(MeshRenderer);\r\n        }\r\n        return this._node;\r\n    }\r\n\r\n    graphicsMapLine() {\r\n        const node = this.node;\r\n        const box = node.getComponent(BoxCollider);\r\n        const lineBox = new Node(\"line-box\");\r\n        node.addChild(lineBox);\r\n        let line = lineBox.addComponent(Line);\r\n        v3_1.set(box.worldBounds.halfExtents);\r\n        const hGridCount = Math.floor(v3_1.x * 2 / GlobalConst.mapGridWidth);\r\n        const vGridCount = Math.floor(v3_1.z * 2 / GlobalConst.mapGridHeight);\r\n        for (let x = 0; x < hGridCount; x++) {\r\n\r\n            for (let y = 0; y < vGridCount; y++) {\r\n                (<Vec3[]>line.positions).push(\r\n                    v3(v3_1.x - GlobalConst.mapGridWidth * x, 0.2, v3_1.z - GlobalConst.mapGridHeight * y)\r\n                );\r\n            }\r\n        }\r\n        line.width.constant = 0.1;\r\n        line.positions = line.positions;\r\n    }\r\n\r\n    /** 计算触发到地图上的点位, 传入屏幕坐标 */\r\n    public calculateHitPoint(vec2: Vec2, out: Vec3) {\r\n        if (!this._node) this.node;\r\n        const camera = GlobalConst.camera;\r\n        camera.screenPointToRay(vec2.x, vec2.y, ray);\r\n        let dis = geometry.intersect.rayModel(ray, this._meshRender.model);\r\n        if (dis) {\r\n            ray.computeHit(mapHitPoint, dis); // 性能要好些\r\n            out && out.set(mapHitPoint);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** 获取点击的格子, 传入屏幕坐标*/\r\n    public getHitPointToGrid(vec2: Vec2, out: Vec2) {\r\n        if (this.calculateHitPoint(vec2, mapHitPoint)) {\r\n            this.node.inverseTransformPoint(v3_1, mapHitPoint);\r\n            const scale = this.node.scale;\r\n            let scaleX = GlobalConst.mapGridWidth / scale.x;\r\n            let scaleY = GlobalConst.mapGridHeight / scale.z;\r\n\r\n            out.x = Math.floor(v3_1.x / scaleX);\r\n            out.y = Math.floor(v3_1.z / scaleY);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** 获取点击的格子中心坐标, 传入屏幕坐标 */\r\n    public getHitPointToGridPosition(vec2: Vec2, out: Vec3, outGrid: Vec2) {\r\n        if (this.calculateHitPoint(vec2, mapHitPoint)) {\r\n            this._setMapPos(out, outGrid);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private _setMapPos(out: Vec3, outGrid: Vec2) {\r\n        this.node.inverseTransformPoint(v3_1, mapHitPoint);\r\n        const scale = this.node.scale;\r\n        let scaleX = GlobalConst.mapGridWidth / scale.x;\r\n        let scaleY = GlobalConst.mapGridHeight / scale.z;\r\n\r\n        outGrid.x = Math.floor(v3_1.x / scaleX);\r\n        outGrid.y = Math.floor(v3_1.z / scaleY);\r\n\r\n        out.x = (outGrid.x + 0.5) * scaleX;\r\n        out.y = out.y;\r\n        out.z = (outGrid.y + 0.5) * scaleY;\r\n\r\n        this.node.getWorldMatrix(worldMatrix);\r\n        Vec3.transformMat4(out, out, worldMatrix);\r\n    }\r\n}"]}