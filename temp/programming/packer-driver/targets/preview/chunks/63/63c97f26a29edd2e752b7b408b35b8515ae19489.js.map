{"version":3,"sources":["file:///D:/cocos_work/SimulateCity/assets/src/MapMgr.ts"],"names":["MapMgr","Vec3","geometry","GlobalConst","ray","v3_1","worldMatrix","constructor","_node","node","mapPanel","calculateHitPoint","vec2","out","camera","screenPointToRay","x","y","dis","intersect","rayModel","_meshRender","model","computeHit","mapHitPoint","set","getHitPointToGrid","inverseTransformPoint","scale","scaleX","mapGridWidth","scaleY","mapGridHeight","z","Math","floor","getHitPointToGridPosition","outGrid","_setMapPos","getWorldMatrix","transformMat4"],"mappings":";;;oIAGaA,M;;;;;;;;;;;;;;;;;;;;;;;;;;;AAHQC,MAAAA,I,OAAAA,I;AAAMC,MAAAA,Q,OAAAA,Q;;AAClBC,MAAAA,W,iBAAAA,W;AAAaC,MAAAA,G,iBAAAA,G;AAAKC,MAAAA,I,iBAAAA,I;AAAMC,MAAAA,W,iBAAAA,W;;;;;;;;;wBAEpBN,M,GAAN,MAAMA,MAAN,CAAY;AAEf;AACA;AACA;AACA;AAGAO,QAAAA,WAAW,GAAE;AAAA,eAFbC,KAEa;AAEZ;;AAGc,YAAJC,IAAI,GAAE;AACb,iBAAO,KAAKD,KAAZ,KAAO,KAAKA,KAAZ,GAAsB;AAAA;AAAA,0CAAYE,QAAlC;AACH;AAED;;;AACOC,QAAAA,iBAAiB,CAACC,IAAD,EAAaC,GAAb,EAAyB;AAC7C,cAAMC,MAAM,GAAG;AAAA;AAAA,0CAAYA,MAA3B;AACAA,UAAAA,MAAM,CAACC,gBAAP,CAAwBH,IAAI,CAACI,CAA7B,EAAgCJ,IAAI,CAACK,CAArC;AAAA;AAAA;AACA,cAAIC,GAAG,GAAGhB,QAAQ,CAACiB,SAAT,CAAmBC,QAAnB;AAAA;AAAA,0BAAiC,KAAKC,WAAL,CAAiBC,KAAlD,CAAV;;AACA,cAAIJ,GAAJ,EAAS;AACL;AAAA;AAAA,4BAAIK,UAAJ,CAAeC,WAAf,EAA4BN,GAA5B,EADK,CAC6B;;AAClCL,YAAAA,GAAG,IAAIA,GAAG,CAACY,GAAJ,CAAQD,WAAR,CAAP;AACA,mBAAO,IAAP;AACH;;AACD,iBAAO,KAAP;AACH;AAED;;;AACOE,QAAAA,iBAAiB,CAACd,IAAD,EAAaC,GAAb,EAAwB;AAC5C,cAAI,KAAKF,iBAAL,CAAuBC,IAAvB,CAAJ,EAAkC;AAC9B,iBAAKH,IAAL,CAAUkB,qBAAV;AAAA;AAAA,8BAAsCH,WAAtC;AACA,gBAAMI,KAAK,GAAG,KAAKnB,IAAL,CAAUmB,KAAxB;AACA,gBAAIC,MAAM,GAAG;AAAA;AAAA,4CAAYC,YAAZ,GAA2BF,KAAK,CAACZ,CAA9C;AACA,gBAAIe,MAAM,GAAG;AAAA;AAAA,4CAAYC,aAAZ,GAA4BJ,KAAK,CAACK,CAA/C;AAEApB,YAAAA,GAAG,CAACG,CAAJ,GAAQkB,IAAI,CAACC,KAAL,CAAW;AAAA;AAAA,8BAAKnB,CAAL,GAASa,MAApB,CAAR;AACAhB,YAAAA,GAAG,CAACI,CAAJ,GAAQiB,IAAI,CAACC,KAAL,CAAW;AAAA;AAAA,8BAAKF,CAAL,GAASF,MAApB,CAAR;AACA,mBAAO,IAAP;AACH;;AACD,iBAAO,KAAP;AACH;AAED;;;AACOK,QAAAA,yBAAyB,CAACxB,IAAD,EAAaC,GAAb,EAAwBwB,OAAxB,EAAsC;AAClE,cAAI,KAAK1B,iBAAL,CAAuBC,IAAvB,CAAJ,EAAkC;AAC9B,iBAAK0B,UAAL,CAAgBzB,GAAhB,EAAoBwB,OAApB;;AACA,mBAAO,IAAP;AACH;;AACD,iBAAO,KAAP;AACH;;AAEOC,QAAAA,UAAU,CAACzB,GAAD,EAAWwB,OAAX,EAAyB;AACvC,eAAK5B,IAAL,CAAUkB,qBAAV;AAAA;AAAA,4BAAsCH,WAAtC;AACA,cAAMI,KAAK,GAAG,KAAKnB,IAAL,CAAUmB,KAAxB;AACA,cAAIC,MAAM,GAAG;AAAA;AAAA,0CAAYC,YAAZ,GAA2BF,KAAK,CAACZ,CAA9C;AACA,cAAIe,MAAM,GAAG;AAAA;AAAA,0CAAYC,aAAZ,GAA4BJ,KAAK,CAACK,CAA/C;AAEAI,UAAAA,OAAO,CAACrB,CAAR,GAAYkB,IAAI,CAACC,KAAL,CAAW;AAAA;AAAA,4BAAKnB,CAAL,GAASa,MAApB,CAAZ;AACAQ,UAAAA,OAAO,CAACpB,CAAR,GAAYiB,IAAI,CAACC,KAAL,CAAW;AAAA;AAAA,4BAAKF,CAAL,GAASF,MAApB,CAAZ;AAEAlB,UAAAA,GAAG,CAACG,CAAJ,GAAQ,CAACqB,OAAO,CAACrB,CAAR,GAAY,GAAb,IAAoBa,MAA5B;AACAhB,UAAAA,GAAG,CAACI,CAAJ,GAAQJ,GAAG,CAACI,CAAZ;AACAJ,UAAAA,GAAG,CAACoB,CAAJ,GAAQ,CAACI,OAAO,CAACpB,CAAR,GAAY,GAAb,IAAoBc,MAA5B;AAEA,eAAKtB,IAAL,CAAU8B,cAAV;AAAA;AAAA;AACAtC,UAAAA,IAAI,CAACuC,aAAL,CAAmB3B,GAAnB,EAAwBA,GAAxB;AAAA;AAAA;AACH;;AArEc,O","sourcesContent":["import { Node, Vec2, Vec3, geometry } from \"cc\";\r\nimport { GlobalConst, ray, v3_1, worldMatrix } from \"./GlobalConst\";\r\n\r\nexport class MapMgr{\r\n\r\n    // 地图块的计算，当前地图有多少格子，那些格子可用\r\n    // 当前地图存在的建筑物\r\n    // 建筑物对应的状态\r\n    // 各个建筑物的状态更新\r\n    _node:Node;\r\n\r\n    constructor(){\r\n        \r\n    }\r\n\r\n\r\n    public get node(){\r\n        return this._node ||= GlobalConst.mapPanel;\r\n    }\r\n    \r\n    /** 计算触发到地图上的点位, 传入屏幕坐标 */\r\n    public calculateHitPoint(vec2: Vec2, out?: Vec3) {\r\n        const camera = GlobalConst.camera;\r\n        camera.screenPointToRay(vec2.x, vec2.y, ray);\r\n        let dis = geometry.intersect.rayModel(ray, this._meshRender.model);\r\n        if (dis) {\r\n            ray.computeHit(mapHitPoint, dis); // 性能要好些\r\n            out && out.set(mapHitPoint);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** 获取点击的格子, 传入屏幕坐标*/\r\n    public getHitPointToGrid(vec2: Vec2, out: Vec2) {\r\n        if (this.calculateHitPoint(vec2)) {\r\n            this.node.inverseTransformPoint(v3_1, mapHitPoint);\r\n            const scale = this.node.scale;\r\n            let scaleX = GlobalConst.mapGridWidth / scale.x;\r\n            let scaleY = GlobalConst.mapGridHeight / scale.z;\r\n\r\n            out.x = Math.floor(v3_1.x / scaleX);\r\n            out.y = Math.floor(v3_1.z / scaleY);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /** 获取点击的格子中心坐标, 传入屏幕坐标 */\r\n    public getHitPointToGridPosition(vec2: Vec2, out: Vec3, outGrid:Vec2) {\r\n        if (this.calculateHitPoint(vec2)) {\r\n            this._setMapPos(out,outGrid);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private _setMapPos(out: Vec3,outGrid:Vec2) {\r\n        this.node.inverseTransformPoint(v3_1, mapHitPoint);\r\n        const scale = this.node.scale;\r\n        let scaleX = GlobalConst.mapGridWidth / scale.x;\r\n        let scaleY = GlobalConst.mapGridHeight / scale.z;\r\n        \r\n        outGrid.x = Math.floor(v3_1.x / scaleX);\r\n        outGrid.y = Math.floor(v3_1.z / scaleY);\r\n\r\n        out.x = (outGrid.x + 0.5) * scaleX;\r\n        out.y = out.y;\r\n        out.z = (outGrid.y + 0.5) * scaleY;\r\n\r\n        this.node.getWorldMatrix(worldMatrix);\r\n        Vec3.transformMat4(out, out, worldMatrix);\r\n    }\r\n}"]}